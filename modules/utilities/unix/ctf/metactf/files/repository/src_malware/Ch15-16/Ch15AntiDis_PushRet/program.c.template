#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ptrace.h>
#define USERDEF AAAAAA

#define MAX_LENGTH 256

#define INJECT_FALSERET asm volatile (\
        "  pushl %ecx        \n"      \
        "  pushl %ebx        \n"      \
        "  pushl %edx        \n"      \
        "  movl  %esp, %ebx  \n"      \
        "  movl  %ebp, %esp  \n"      \
        "  popl  %ebp        \n"      \
        "  popl  %ecx        \n"      \
        "  lea   0f, %edx    \n"      \
        "  pushl %edx        \n"      \
        "  ret               \n"      \
        "  .byte 0x0F        \n"      \
        "0:                  \n"      \
        "  pushl %ecx        \n"      \
        "  pushl %ebp        \n"      \
        "  movl  %esp, %ebp  \n"      \
        "  movl  %ebx, %esp  \n"      \
        "  popl  %ebx        \n"      \
        "  popl  %ecx        \n")

#define INJECT_TRANSPOSE asm (\
	" .transpose:		\n"	\
	" nop			\n"	\
	" jmp .one		\n"	\
	" .two:      	 	\n"	\
	" pushl %ebx		\n"	\
	" jmp .continue		\n"	\
	" movl $1, %eax		\n"	\
	" movl $0, %ebx		\n"	\
	" int $0x80		\n"	\
	" .one:			\n"	\
	" xorl %eax, %eax	\n"	\
	" incl %eax		\n"	\
	" jmp .two		\n"	\
	" .continue:		\n"	\
	" nop			\n")
#define INJECT_CHECKIT_LABEL asm (\
	" .checkit:	\n"	\
	" nop		\n");
#define INJECT_PRINTGOOD_LABEL asm (\
	" .pgood:	\n"	\
	" nop		\n");
#define INJECT_PRINTAGAIN_LABEL asm (\
	" .pagain:	\n"	\
	" nop		\n");
#define INJECT_END_LABEL asm (\
	" .end:	\n"	\
	" nop		\n");

#define INJECT_CHECKIT_CALL asm (\
	" pushl $.checkit	\n"	\
	" ret			\n");
#define INJECT_TRANSPOSE_CALL asm (\
	" pushl $.transpose	\n"	\
	" ret		\n");
#define INJECT_PRINTGOOD_CALL asm (\
	" pushl $.pgood	\n"	\
	" ret		\n");
#define INJECT_PRINTAGAIN_CALL asm (\
	" pushl $.pagain \n"	\
	" ret		\n");
#define INJECT_END_CALL asm (\
	" pushl $.end	\n"	\
	" ret		\n");

/* If you don't care what is at top of stack, you can also use
	movl $.checkit, (%esp)
	ret
*/

void printflag();

char msg[] =
 "In this level, the path of code execution has been obfuscated using\n"
 "code transposition and a non-standard jumps that push an address onto\n"
 "the stack before issuing a return.  Bypass these techniques to discover\n"
 "how the passcode is set and modified before being checked.\n\n";

/* Symbolic execution trap */
void print_msg() {
  unsigned int i,h1,h2;
  unsigned int len=strlen(msg);
  for (i = 0; i < 100*len; i++) {
    h1 += msg[i%len] + msg[(i+1)%len];
    h2 += msg[(i+1)%len] + msg[(i+2)%len];
  }
  if (h1 == h2)
    printf("%s",msg);
  else
    printf("%s",msg);
}

void print_good(void){
	INJECT_PRINTGOOD_LABEL;
	printf("Good Job.\n");
	printflag();
	INJECT_END_CALL;
}

void print_again(void){
	INJECT_PRINTAGAIN_LABEL;
	printf("Try again.\n");
	INJECT_END_CALL;
}

int code=0;
int check=0;

int check_it() {
	INJECT_CHECKIT_LABEL;
	check += 5;
	INJECT_TRANSPOSE_CALL;
}

void detectTrace(void) __attribute__((constructor));
void detectTrace (void) {
    if(ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
        printf("Sorry, we have disallowed debuggers on this assignment.\n");
        exit(1);
    };
};

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main(int argc, char* argv[]) {

	check = USERDEF;
	print_msg();
	printf("Enter in the password: ");

	scanf("%d", &code);
	sleep(1);

	INJECT_CHECKIT_CALL;

	/* Two train-wrecks.  One is a fake exit call that is unreachable. */
	/* The other is a false return.  Execution will go straight through.*/
	INJECT_TRANSPOSE;
	INJECT_FALSERET;

	if (code == check) {
		INJECT_PRINTGOOD_CALL;
	} else {
		INJECT_PRINTAGAIN_CALL;
	}
	INJECT_END_LABEL;
}
