/* Adapted from Andre Lopez CS 492/592 Winter 2017 */
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/wait.h>
#define USERDEF "AAAAAA"

void printflag();

const int SZ = 8;


char msg[] = \
"Processes can communicate using a variety of inter-process communication\n\
channels.  One of these channels is a pipe.  In this level, you will need to\n\
determine the passcode that will unlock the binary by analyzing the binary\n\
using gdb.  The password is sent via a pipe that is created between the\n\
parent and child.  Find where this communication happens and trace execution\n\
either in the child or parent to determine the password.  You can employ\n\
gdb's set folow-fork-mode <child|parent> to do so.\n\n";

void print_good() {
	printf("Good Job.\n");
    printflag();
    exit(0);
}

// Print try again
void print_again() {
    printf("Try again.\n");
}

// Print the directions
/* Symbolic execution trap */
void print_msg() {
  unsigned int i,h1,h2;
  unsigned int len=strlen(msg);
  for (i = 0; i < 100*len; i++) {
    h1 += msg[i%len] + msg[(i+1)%len];
    h2 += msg[(i+1)%len] + msg[(i+2)%len];
  }
  if (h1 == h2)
    printf("%s",msg);
  else
    printf("%s",msg);
}


// All the work
void try_command() {
    int fd[2]; // For the pipe
    int status; //For the wait
    int len = strlen(USERDEF); // Getting the length
    pipe(fd);// Create the pipe
    int pid = fork(); // Create the fork
    int i;

    // If pipe fails
    if(pid < 0)
    {
        perror("\nFork\n");
        return;
    }
    // In child
    if(pid == 0)
    {
        // Close the pipe
        close(fd[1]);
        char userpass[100];
        char buffer[100];
        bool correct = false;

        printf("Enter the password: ");
        scanf("%8s", userpass);

        // Read from the pipe
        read(fd[0], buffer, sizeof(buffer));

        // For debugging reasons
        //printf("Real Password: %s",buffer);

        // Check letter by letter. 
        for(i = 0;i < len; i++)
        {
            if (userpass[i])
            {
                //printf("checking: %c\n", comp);
                if (buffer[i] == userpass[i])
                {
                    correct = true;
                }
                else
                {
                    correct = false;
                    break;
                }
            }
            else
            {
                correct = false;
                break;
            }

        }

        // IF good print good else try again
        if(correct)
            print_good();
        else
            print_again();
        exit(0);
        //printf("I am the child\n");
    }
    // In the parent
    else
    {
        // Close the pipe
        close(fd[0]);
        char realpass[12];
        char oldpass[] = USERDEF;

        // Convert password to the new password
        for(i = 0; i < len; i++)
            realpass[i] = oldpass[(i+5)%8];
        realpass[len]=0;

        // For debugging reasons
        //printf("\nRealPass: %s\n",realpass);
        //printf("Strlen of realpass: %d\n", strlen(realpass));

        // Send in a pipe
        write(fd[1], realpass, (strlen(realpass)+1));
        // Wait for child to exit to exit.
        wait(&status);
        exit(0);
    }
}

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main() {
    print_msg();
    try_command();
    return 0;
}
