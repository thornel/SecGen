#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <signal.h>
#include <sys/ptrace.h>
#define USERDEF "AAAAAA"

void printflag();

char msg[] =
 "One of the ways malware can detect if it is being debugged or traced is to\n"
 "check the SIGTRAP signal handler.  Since debuggers typically hijack the\n"
 "SIGTRAP signal (INT 3) to implement software breakpoints, a program can\n"
 "install a SIGTRAP handler and detect if it has been clobbered by the\n"
 "debugger.  This program exits if it detects that its SIGTRAP handler\n"
 "has been overwritten.  Bypass this check to complete the level.\n\n";

/* Symbolic execution trap */
void print_msg() {
  unsigned int i,h1,h2;
  unsigned int len=strlen(msg);
  for (i = 0; i < 100*len; i++) {
    h1 += msg[i%len] + msg[(i+1)%len];
    h2 += msg[(i+1)%len] + msg[(i+2)%len];
  }
  if (h1 == h2)
    printf("%s",msg);
  else
    printf("%s",msg);
}

/* SIGTRAP trick: GDB handle SIGTRAP, if raise one under GDB, it will not reach the handler and set the flag */
int debugged = 1;

static void sigtrap_handler(int signum){
  debugged = 0;
}

void sigtrap(){
  signal(SIGTRAP, sigtrap_handler);
  raise(SIGTRAP);
  if (debugged) exit(0);
}

void print_good(void){
	            printf("Good Job.\n");
                printflag();
}

void print_again(void){
                printf("Try again.\n");
}

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main(int argc, char* argv[])
{
  int i;
  char final[20]="";
  char input[20]="";

  print_msg();
  printf("Enter the password: ");
  scanf("%19s",input);
  sigtrap();
  strncpy(final, USERDEF, 8);
  if(strcmp(input, final))
	print_again();
  else
	print_good();
  return 0;
}
