#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#define USERDEF AAAAAA

void printflag();

typedef void (*funcp)();

typedef struct f {
    char c1;
    double d;
    char c2;
} mystruct;

char msg[] =
 "This insecure menu system takes a numeric input as an index to a function\n"
 "a 3-entry function table, only it doesn't validate the user's input to ensure\n"
 "it doesn't exceed the size of the table.  To solve this level, find the index\n"
 "that will go beyond the array of mystructs and invoke a function whose\n"
 "address happens to be located in the caller's stack frame.  To make this\n"
 "level easier, we have included the source code used to generate your binary.\n"
 "You will need to calculate the number of bytes on the stack that sit\n"
 "between the function table and the location of the function pointer fg\n"
 "in main.\n\n";

void print_msg() {
    printf("%s",msg);
}

void segv_handler(int sig) {
        printf("Segmentation fault.  Try again.\n");
        exit(0);
}

void print_good() {
	printf("Good Job.\n");
    printflag();
    exit(0);
}

void print_nogood() {
    printf("Try again.\n");
}
void print_helloworld() {
    printf("Hello world.\n");
}
void print_nosoup () {
    printf("No soup for you.\n");
}
void try_command() {
    int i;
    mystruct m[USERDEF];
    funcp f[3] = {print_nogood, print_helloworld, print_nosoup};
    printf("The password is the command to execute (0=nogood, 1=helloworld, 2=nosoup)\n");
    printf("Enter the password: ");
    sleep(2);
    scanf("%d",&i);
    f[i]();
}

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main() {
    funcp fg=print_good;
    signal(SIGSEGV, segv_handler);
    print_msg();
    try_command();
    print_nogood();
    return 0;
}
